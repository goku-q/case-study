一、synchronized底层原理
java虚拟机中同步机制是基于monitor对象实现的（字节码文件中可以看到monitorentry，monitorexit指令来控制锁和释放），方法级的同步是隐式的，字节码中没有monitorentry等指令，而是通过JVM方法常量池中的方法表结构（method_info Structure)中的ACC_SYNCHRONIZED来区分方法是否为同步方法。
二、对象的内存布局
JVM中对象在内存中的存储分为三块区域：对象头（header）、实例数据（instance data）、对齐填充（padding）。
1、对象头，用于存储对象运行时的数据，如hashcode、GC分代、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等。官方成为“MARK WORD”。
		HostSpot 虚拟机对象头 Mark Word
存储内容				标志位				状态
对象哈希码、对象分代年龄			01				未锁定
指向锁记录的指针			00				轻量级锁
指向重量级锁				10				膨胀（重量级锁）
空，不需要记录信息			11				GC标记
偏向线程ID、偏向时间戳、对象分代年龄	01				可偏向

2、实例数据，用于真正存储的有效信息，也就是代码中定义的各种类型的字段内容。
3、对齐填充，没有实际意义，只是占位符。HotSpot VM 自动内存管要求对象起始地址必须是8bit的整数倍，对象头正好是8bit的倍数（32bit、64bit），实例数据如果没有对齐8bit的倍数，则需要通过对齐填充来补全。
三、synchronized升级
锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，不可以降级。
1、无锁状态
2、偏向锁：偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。
3、轻量级锁：原理就是CAS（Compare-And-Swap）比较并交换
4、重量级锁：synchronized锁


升级概述：
1、先是无锁状态--> 获得偏向锁（当前获取到锁资源的线程，会优先让它再次获得锁），如果没有获取到锁 --> 升级成轻量级锁CAS的乐观锁（compare and swap），如果没有成功会进行自旋，自旋一定次数后（自适应自旋）还没有成功的话，升级成synchronized -->重量级锁synchronized
